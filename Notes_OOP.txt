ООП
--------------------------------------------- 
класс - описание сущности предметной области, позволяющее выделить общие характеристики, состояние, поведение
предметная область - множество всех предметов решаемой проблемы
экземпляр класса- конкретный представитель класса (не стоит отождествлять с обьектом класса)
состояние - набор данных (полей, констаныты, события)
поведение - методы (функции для работы с данными), конструкторы

Обьектно-ориентированный подход - это попытка мыслить и проектировать системы с использованием классов и экземпляров классов

переопределение - @OVERRIDE меняем поведение, которое было до нас
перегрузка - описываем в рамках одной сущности метода, разной сигнатуры(набор типов). переопределяем количество аргументов у метода. если перерузка, то JDTHHFQL  писать не надо
---------------------------------------------
ПРинципы ООП:
Инкапсуляция 
свойство системы, позволяющее обьединить данные и методы, работающие с ними в классе, скрыв детали реализации и защитив от пользователя этого класса обьектов
Модификация переменных обьекта должна происходить в самом обьекте

Наследование
public class Magician extends BaseHero - значит Magician яыляентся наследником(производным, дочерним) BaseHero (родительский)

Полиморфизм 
возможность положить в (полиморфную) переменную базового класса любую из его производных.
это свойство системы использовать обьекты с одинаковым интерфейсом без информации о типе и внутренней структуре обьекта

Абстракция(не совсем принцип) - берем предметную область, убираем лишнее, упрощаем без потери смысла
свойство системы, когда описывают общие характеристики базового класса для всех его производных класса, а наполнение деталями предоставляется каждому из этих классов


----------------
модификаторы доступа: 
public - доступно везде
private - доступно только в текущем классе
protected - доступно в рамках текущего класса и наследников

this. - обращение к отдельной единице текущей сущности(класса)
super. - обращение к родительскому (базовому) классу

static вызывается из имени класса, this и super не нужны. обращаться к статическим членам через тип
    создаются в самом начале, существуют все время выполнения программы
    код который нужен именно в этом классе. 

abstract - ограничение создания экземпляра абстрактного типа.
абстрактный метод - обозначена сигнатура, а тело реализуется в потомках класса

Интерфейс - предназначен для описания исключительно общего поведения сущностей. 
   !!! абстр.класс призван описывать структуру обьекта (нельзя расширять), интерфейс - сущность которая обязывает соблюдать абстрактные методы, Поведение, (можно расширять)
   Частный случай класса. Представляет собой полностью абстрактный класс с абстрактными членами
   !!! если нужно поведение - используем интерфейс, если нужен концептуальный обьект - используем класс
   
   
   public interface Warior{метод}
   public class Palladin extends Hero implements Warior, Healer{ Оверрайд и дописываем метод}

Архитектурная прадигма - MVC - model<->View<->controller
model - какая-то база данных
controller - бэк приложение
view - фронт
model  и view обменимаются данными через controller. 

Использование интерфейса итератор:
Iterator iterator = someList.iteretor();
while(iterator.hasNext()){
    var i=iterator.next();
    System.out.println(i);
} //аналогично форич
iterator.remove() удалять через итератор правильно, модифицировать коллекцию через итератор

Iterable<E> позволяет собственному типу быть типом оператора "for-each loop"

при работе с аррей листом указывать не аррей лист, а лист. 
те. при создании переменной указывать не конкретный класс, а интерфейс(наз. апкаст)
 
Comparable<E> сравнение и сортировка по 1 логике
0 это равентсво
1 объект у которого вызывается Compareto больше которой кладется в него
-1 меньше
Comparator<E> сравнение и сортировка 2 обьектов на входе, сравнение по разным параметрам

Singleton:
паттерн, когда у класса может быть ОДИН экземпляр, дает глобальную точку доступа к этому экземпляру
    1. приватные конструкторы
    2. обьявить статическую переменную, которая содержит единый экземпляр
    3. фабричный метод, который при необходимости вызывает конструктор:
        if(staticInstanse==null){
            staticInstanse=new Instance();
        }
        return staticInstanse;
Статический метод видит только статические переменные и методы.
надо или в него передавать конкретный экземпляр, или использовать внутри статические переменные




